<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="no-referrer" />
    <title>小说搜索与下载</title>
    <script id="FileSaver.js" src="https://s4.zstatic.net/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- 自己把下面两行取消注释启用移动端开发者工具 -->
    <!-- <script id="eruda.js" src="https://s4.zstatic.net/ajax/libs/eruda/3.4.1/eruda.min.js" integrity="sha512-3RVqOZtMevFOLeXCp0/Wl7np/l3J3MMysaFDUhNh+hdKx+Wb0lMXuHwA6CZ/+4DfYZM01Om1as8g+mnTaQH9vA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> -->
    <!-- <script> eruda.init() </script> -->
    <script id="moment.js" src="https://s4.zstatic.net/ajax/libs/moment.js/2.30.1/moment.min.js"></script>
    <script id="lodash.js" src="https://s4.zstatic.net/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script
      id="jszip"
      src="https://s4.zstatic.net/ajax/libs/jszip/3.10.1/jszip.min.js"
      integrity="sha512-XMVd28F1oH/O71fzwBnV7HucLxVwtxf26XV8P4wPk26EDxuGZ91N8bsOttmnomcCD3CS5ZMRL50H0GgOHvegtg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script id="gbk.js">
      // 本来是压缩过的，结果格式化工具又给我格式化了，干脆不管了
      'use strict'
      let table
      function initGbkTable() {
        var r,
          t,
          e,
          o,
          n = new Uint16Array(23940)
        let f = 0
        for ([r, t, e, o] of [
          [161, 169, 161, 254],
          [176, 247, 161, 254],
          [129, 160, 64, 254],
          [170, 254, 64, 160],
          [168, 169, 64, 160],
          [170, 175, 161, 254],
          [248, 254, 161, 254],
          [161, 167, 64, 160],
        ])
          for (let l = e; l <= o; l++) if (127 !== l) for (let e = r; e <= t; e++) n[f++] = (l << 8) | e
        ;(table = new Uint16Array(65536)).fill(65535)
        var l = new TextDecoder('gbk').decode(n)
        for (let e = 0; e < l.length; e++) table[l.charCodeAt(e)] = n[e]
      }
      const NodeJsBufAlloc = 'function' == typeof globalThis.Buffer && Buffer.allocUnsafe,
        defaultOnAlloc = NodeJsBufAlloc ? e => NodeJsBufAlloc(e) : e => new Uint8Array(e),
        defaultOnError = () => 63
      window.encodeGBK = function (l, e = {}) {
        table || initGbkTable()
        var r = e.onAlloc || defaultOnAlloc,
          t = e.onError || defaultOnError,
          o = r(2 * l.length)
        let n = 0
        for (let e = 0; e < l.length; e++) {
          var f = l.charCodeAt(e)
          if (f < 128) o[n++] = f
          else {
            var a = table[f]
            if (65535 !== a) (o[n++] = a), (o[n++] = a >> 8)
            else if (8364 === f) o[n++] = 128
            else {
              a = t(e, l)
              if (-1 === a) break
              255 < a ? ((o[n++] = a), (o[n++] = a >> 8)) : (o[n++] = a)
            }
          }
        }
        return o.subarray(0, n)
      }
    </script>
    <script id="epub-saver.js">
      'use strict'
      class EpubSaver {
        constructor() {
          this.zip = new JSZip()
          this.metadata = new Map()
          this.volumes = new Map()
          this.cssFiles = new Map()
          this.cssMap = new Map()
          this.cssPathMapping = new Map() // Maps original CSS paths to final EPUB paths
          this.images = new Map() // Store downloaded images: filename -> {buffer, extension}
          this.coverBuffer = null
          this.coverExtension = null

          // Set default metadata
          this.setInfo('identifier', crypto.randomUUID(), { scheme: 'uuid' })
          this.setInfo('date', moment().format('YYYY-MM-DDTHH:mm:ss[Z]'), { 'opf:event': 'modification' })
          this.setInfo('language', 'en')
          this.setInfo('title', 'Untitled Book')
          this.setInfo('creator', 'Unknown Author')
        }

        async setInfo(key, value, options = {}) {
          this.metadata.set(key, { value, options })
        }

        async cover(input) {
          if (typeof input === 'string') {
            // It's a URL, fetch it
            try {
              const response = await fetch(input)
              if (!response.ok) {
                throw new Error(`Failed to fetch cover: ${response.statusText}`)
              }
              this.coverBuffer = await response.arrayBuffer()

              // Determine extension from content type or URL
              const contentType = response.headers.get('content-type')
              if (contentType) {
                if (contentType.includes('jpeg') || contentType.includes('jpg')) {
                  this.coverExtension = 'jpg'
                } else if (contentType.includes('png')) {
                  this.coverExtension = 'png'
                } else if (contentType.includes('gif')) {
                  this.coverExtension = 'gif'
                } else {
                  this.coverExtension = 'jpg' // default
                }
              } else {
                // Try to determine from URL
                const ext = input.split('.').pop().toLowerCase()
                this.coverExtension = ['jpg', 'jpeg', 'png', 'gif'].includes(ext) ? ext : 'jpg'
              }
            } catch (error) {
              throw new Error(`Failed to fetch cover image: ${error.message}`)
            }
          } else {
            // It's a buffer
            this.coverBuffer = input
            this.coverExtension = 'jpg' // default, could be enhanced to detect type
          }
        }

        async addVolume(idx, title) {
          const volume = new EpubVolume(idx, title, this)
          this.volumes.set(idx, volume)
          return volume
        }

        async addCSS(idx, content, mappath) {
          if (this.cssFiles.has(idx) && mappath && this.cssFiles.get(idx).mappath !== mappath) {
            throw new Error(`CSS index ${idx} already exists with different mappath`)
          }

          this.cssFiles.set(idx, { content, mappath })
        }

        async addCSSMap(pathMap) {
          for (const [originalPath, urlOrContent] of Object.entries(pathMap)) {
            // Normalize the original path (remove leading "Styles/" if present)
            const normalizedOriginal = originalPath.startsWith('Styles/') ? originalPath.substring(7) : originalPath

            // Create final EPUB path (always under Styles/)
            const finalPath = normalizedOriginal

            // Store the mapping for reference updates
            this.cssPathMapping.set(originalPath, `../Styles/${finalPath}`)

            if (typeof urlOrContent === 'string' && urlOrContent.startsWith('http')) {
              // It's a URL, fetch it
              try {
                const response = await fetch(urlOrContent)
                if (!response.ok) {
                  throw new Error(`Failed to fetch CSS from ${urlOrContent}: ${response.statusText}`)
                }
                const content = await response.text()
                this.cssMap.set(finalPath, content)
              } catch (error) {
                throw new Error(`Failed to fetch CSS: ${error.message}`)
              }
            } else {
              // It's content
              this.cssMap.set(finalPath, urlOrContent)
            }
          }
        }

        async _processCSSLinksInContent(content) {
          if (typeof content !== 'string') return content

          // Decode Unicode escape sequences if present
          let decodedContent = content
          try {
            decodedContent = JSON.parse('"' + content.replace(/"/g, '\\"') + '"')
          } catch (error) {
            // If JSON parsing fails, use original content
            decodedContent = content
          }

          try {
            const parser = new DOMParser()
            let doc

            // Try to parse as HTML first
            if (decodedContent.includes('<html') || decodedContent.includes('<!DOCTYPE')) {
              doc = parser.parseFromString(decodedContent, 'text/html')
            } else {
              // Wrap fragment in temporary HTML for parsing
              const wrapped = `<html><head></head><body>${decodedContent}</body></html>`
              doc = parser.parseFromString(wrapped, 'text/html')
            }

            const cssLinks = doc.querySelectorAll('link[rel="stylesheet"], link[type="text/css"]')

            for (const link of cssLinks) {
              const href = link.getAttribute('href')
              if (href) {
                // Check if this CSS path is in our mapping
                if (this.cssPathMapping.has(href)) {
                  // Update to mapped path
                  const mappedPath = this.cssPathMapping.get(href)
                  link.setAttribute('href', mappedPath)
                  console.log(`Updated CSS reference: ${href} -> ${mappedPath}`)
                } else {
                  // CSS not in map, warn and remove the link
                  console.warn(`CSS reference not found in CSSMap, removing: ${href}`)
                  link.remove()
                }
              }
            }

            // Return updated content
            if (decodedContent.includes('<html') || decodedContent.includes('<!DOCTYPE')) {
              const serializer = new XMLSerializer()
              return serializer.serializeToString(doc.documentElement)
            } else {
              // Extract just the body content for fragments
              return doc.body.innerHTML
            }
          } catch (error) {
            console.warn('Error processing CSS links in content:', error)
            return decodedContent
          }
        }

        async _downloadImagesFromContent(content) {
          if (typeof content !== 'string') return content

          // Decode Unicode escape sequences if present (content might already be decoded by CSS processing)
          let decodedContent = content
          if (content.includes('\\u')) {
            try {
              decodedContent = JSON.parse('"' + content.replace(/"/g, '\\"') + '"')
            } catch (error) {
              // If JSON parsing fails, use original content
              decodedContent = content
            }
          }

          try {
            const parser = new DOMParser()
            let doc

            // Try to parse as HTML first
            if (decodedContent.includes('<html') || decodedContent.includes('<!DOCTYPE')) {
              doc = parser.parseFromString(decodedContent, 'text/html')
            } else {
              // Wrap fragment in temporary HTML for parsing
              const wrapped = `<html><body>${decodedContent}</body></html>`
              doc = parser.parseFromString(wrapped, 'text/html')
            }

            const images = doc.querySelectorAll('img[src]')
            let imageCounter = this.images.size

            for (const img of images) {
              const src = img.getAttribute('src')

              // Only process external URLs (http/https)
              if (src && (src.startsWith('http://') || src.startsWith('https://'))) {
                let downloadSuccess = false
                let finalUrl = src

                // Try to upgrade HTTP to HTTPS to prevent mixed content errors
                if (src.startsWith('http://')) {
                  const httpsUrl = src.replace('http://', 'https://')
                  try {
                    console.log(`Trying HTTPS upgrade for: ${src}`)
                    const httpsResponse = await fetch(httpsUrl)
                    if (httpsResponse.ok) {
                      console.warn(`Successfully upgraded HTTP to HTTPS: ${src} -> ${httpsUrl}`)
                      finalUrl = httpsUrl
                    }
                  } catch (error) {
                    // HTTPS failed, will try original HTTP URL
                    console.log(`HTTPS upgrade failed for ${src}, trying original URL`)
                  }
                }

                // Try downloading the image
                try {
                  console.log(`Downloading image: ${finalUrl}`)
                  const response = await fetch(finalUrl)
                  if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
                  }

                  const buffer = await response.arrayBuffer()

                  // Determine file extension
                  let extension = 'jpg' // default
                  const contentType = response.headers.get('content-type')
                  if (contentType) {
                    if (contentType.includes('png')) extension = 'png'
                    else if (contentType.includes('gif')) extension = 'gif'
                    else if (contentType.includes('webp')) extension = 'webp'
                    else if (contentType.includes('svg')) extension = 'svg'
                  } else {
                    // Try to get extension from URL
                    const urlExt = finalUrl.split('.').pop().toLowerCase().split('?')[0]
                    if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'].includes(urlExt)) {
                      extension = urlExt
                    }
                  }

                  // Generate unique filename
                  const filename = `image_${imageCounter++}.${extension}`

                  // Store image
                  this.images.set(filename, {
                    buffer,
                    extension,
                    originalUrl: src,
                  })

                  // Update img src to point to local file
                  img.setAttribute('src', `../Images/${filename}`)
                  downloadSuccess = true
                } catch (error) {
                  console.warn(`Failed to download image ${finalUrl}:`, error.message)
                }

                // If download failed, remove the img tag entirely
                if (!downloadSuccess) {
                  console.warn(`Removing failed image tag: ${src}`)
                  img.remove()
                }
              }
            }

            // Return updated content
            if (decodedContent.includes('<html') || decodedContent.includes('<!DOCTYPE')) {
              const serializer = new XMLSerializer()
              return serializer.serializeToString(doc.documentElement)
            } else {
              // Extract just the body content for fragments
              return doc.body.innerHTML
            }
          } catch (error) {
            console.warn('Error processing images in content:', error)
            return decodedContent
          }
        }

        _generateContainer() {
          return `<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
    <rootfiles>
        <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
    </rootfiles>
</container>`
        }

        _generateContentOpf() {
          const uuid = this.metadata.get('identifier')?.value || crypto.randomUUID()
          const title = this.metadata.get('title')?.value || 'Untitled Book'
          const creator = this.metadata.get('creator')?.value || 'Unknown Author'
          const language = this.metadata.get('language')?.value || 'en'
          const date = this.metadata.get('date')?.value || moment().format('YYYY-MM-DDTHH:mm:ss[Z]')

          let metadata = ''
          if (this.coverBuffer) {
            metadata += '        <meta name="cover" content="cover-image" />\n'
          }
          for (const [key, data] of this.metadata) {
            const optionsStr = Object.entries(data.options)
              .map(([k, v]) => `${k}="${v}"`)
              .join(' ')
            metadata += `        <dc:${key}${optionsStr ? ' ' + optionsStr : ''}>${data.value}</dc:${key}>\n`
          }

          let manifest = ''
          let spine = ''
          let manifestItems = []
          let spineItems = []

          // Add navigation files
          manifest += `        <item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>\n`
          manifest += `        <item id="nav" href="nav.xhtml" media-type="application/xhtml+xml" properties="nav"/>\n`
          manifestItems.push('ncx', 'nav')

          // Add cover
          if (this.coverBuffer) {
            // this.setInfo('cover', 'cover-image')
            const mimeType =
              this.coverExtension === 'png' ? 'image/png' : this.coverExtension === 'gif' ? 'image/gif' : 'image/jpeg'
            manifest += `        <item id="cover-image" href="Images/cover.${this.coverExtension}" media-type="${mimeType}" properties="cover-image"/>\n`
            manifest += `        <item id="cover" href="Text/cover.xhtml" media-type="application/xhtml+xml"/>\n`
            manifestItems.push('cover-image', 'cover')
            spineItems.push('cover')
          }

          // Add downloaded images
          for (const [filename, imageData] of this.images) {
            let mimeType = 'image/jpeg' // default
            switch (imageData.extension) {
              case 'png':
                mimeType = 'image/png'
                break
              case 'gif':
                mimeType = 'image/gif'
                break
              case 'webp':
                mimeType = 'image/webp'
                break
              case 'svg':
                mimeType = 'image/svg+xml'
                break
            }
            const imageId = `img-${filename.replace(/[^a-zA-Z0-9]/g, '-')}`
            manifest += `        <item id="${imageId}" href="Images/${filename}" media-type="${mimeType}"/>\n`
            manifestItems.push(imageId)
          }

          // Add CSS files
          for (const [idx, cssData] of this.cssFiles) {
            manifest += `        <item id="css${idx}" href="Styles/style${idx}.css" media-type="text/css"/>\n`
            manifestItems.push(`css${idx}`)
          }

          // Add CSS map files
          for (const path of this.cssMap.keys()) {
            const id = `css-map-${path.replace(/[^a-zA-Z0-9]/g, '-')}`
            manifest += `        <item id="${id}" href="Styles/${path}" media-type="text/css"/>\n`
            manifestItems.push(id)
          }

          // Add chapters from volumes
          const sortedVolumes = Array.from(this.volumes.entries()).sort(([a], [b]) => a - b)
          for (const [volIdx, volume] of sortedVolumes) {
            const sortedChapters = Array.from(volume.chapters.entries()).sort(([a], [b]) => a - b)
            for (const [chapIdx, chapter] of sortedChapters) {
              const id = `chapter-${volIdx}-${chapIdx}`
              const href = `Text/chapter_${volIdx}_${chapIdx}.xhtml`
              manifest += `        <item id="${id}" href="${href}" media-type="application/xhtml+xml"/>\n`
              manifestItems.push(id)
              spineItems.push(id)
            }
          }

          spine = spineItems.map(id => `        <itemref idref="${id}"/>`).join('\n')

          return `<?xml version="1.0" encoding="UTF-8"?>
<package version="3.0" xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId">
    <metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:opf="http://www.idpf.org/2007/opf">
${metadata}    </metadata>
    <manifest>
${manifest}    </manifest>
    <spine toc="ncx">
${spine}
    </spine>
</package>`
        }

        _generateTocNcx() {
          const title = this.metadata.get('title')?.value || 'Untitled Book'
          const uuid = this.metadata.get('identifier')?.value || crypto.randomUUID()

          let navPoints = ''
          let playOrder = 1

          if (this.coverBuffer) {
            navPoints += `        <navPoint id="cover" playOrder="${playOrder++}">
            <navLabel><text>Cover</text></navLabel>
            <content src="Text/cover.xhtml"/>
        </navPoint>\n`
          }

          const sortedVolumes = Array.from(this.volumes.entries()).sort(([a], [b]) => a - b)
          for (const [volIdx, volume] of sortedVolumes) {
            if (volume.chapters.size > 1) {
              // Multiple chapters, create volume entry with sub-chapters
              navPoints += `        <navPoint id="volume-${volIdx}" playOrder="${playOrder++}">
            <navLabel><text>${volume.title}</text></navLabel>
            <content src="Text/chapter_${volIdx}_${Array.from(volume.chapters.keys()).sort((a, b) => a - b)[0]}.xhtml"/>
`
              const sortedChapters = Array.from(volume.chapters.entries()).sort(([a], [b]) => a - b)
              for (const [chapIdx, chapter] of sortedChapters) {
                navPoints += `            <navPoint id="chapter-${volIdx}-${chapIdx}" playOrder="${playOrder++}">
                <navLabel><text>${chapter.title}</text></navLabel>
                <content src="Text/chapter_${volIdx}_${chapIdx}.xhtml"/>
            </navPoint>\n`
              }
              navPoints += `        </navPoint>\n`
            } else {
              // Single chapter, use volume title
              const chapIdx = Array.from(volume.chapters.keys())[0]
              navPoints += `        <navPoint id="volume-${volIdx}" playOrder="${playOrder++}">
            <navLabel><text>${volume.title}</text></navLabel>
            <content src="Text/chapter_${volIdx}_${chapIdx}.xhtml"/>
        </navPoint>\n`
            }
          }

          return `<?xml version="1.0" encoding="UTF-8"?>
<ncx version="2005-1" xmlns="http://www.daisy.org/z3986/2005/ncx/">
    <head>
        <meta content="${uuid}" name="dtb:uid"/>
        <meta content="1" name="dtb:depth"/>
        <meta content="0" name="dtb:totalPageCount"/>
        <meta content="0" name="dtb:maxPageNumber"/>
    </head>
    <docTitle>
        <text>${title}</text>
    </docTitle>
    <navMap>
${navPoints}    </navMap>
</ncx>`
        }

        _generateNavXhtml() {
          const title = this.metadata.get('title')?.value || 'Untitled Book'

          let navItems = ''

          if (this.coverBuffer) {
            navItems += `            <li><a href="Text/cover.xhtml">Cover</a></li>\n`
          }

          const sortedVolumes = Array.from(this.volumes.entries()).sort(([a], [b]) => a - b)
          for (const [volIdx, volume] of sortedVolumes) {
            if (volume.chapters.size > 1) {
              navItems += `            <li>\n                <a href="Text/chapter_${volIdx}_${
                Array.from(volume.chapters.keys()).sort((a, b) => a - b)[0]
              }.xhtml">${volume.title}</a>\n                <ol>\n`
              const sortedChapters = Array.from(volume.chapters.entries()).sort(([a], [b]) => a - b)
              for (const [chapIdx, chapter] of sortedChapters) {
                navItems += `                    <li><a href="Text/chapter_${volIdx}_${chapIdx}.xhtml">${chapter.title}</a></li>\n`
              }
              navItems += `                </ol>\n            </li>\n`
            } else {
              const chapIdx = Array.from(volume.chapters.keys())[0]
              navItems += `            <li><a href="Text/chapter_${volIdx}_${chapIdx}.xhtml">${volume.title}</a></li>\n`
            }
          }

          return `<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>${title} - Table of Contents</title>
        <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0"/>
    </head>
    <body>
        <nav epub:type="toc" id="toc">
            <h1>Table of Contents</h1>
            <ol>
${navItems}            </ol>
        </nav>
    </body>
</html>`
        }

        _generateCoverXhtml() {
          if (!this.coverBuffer) return ''

          const title = this.metadata.get('title')?.value || 'Untitled Book'

          return `<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>${title} - Cover</title>
        <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0"/>
        <style type="text/css">
            body { margin: 0; padding: 0; text-align: center; }
            .cover { width: 100%; height: 100vh; object-fit: contain; }
        </style>
    </head>
    <body>
        <img src="../Images/cover.${this.coverExtension}" alt="Cover" class="cover"/>
    </body>
</html>`
        }

        _formatXML(xmlString) {
          // Simple XML formatter to add proper indentation
          let formatted = ''
          let indent = ''
          const indentStep = '    ' // 4 spaces

          // Split by tags
          const tokens = xmlString.split(/(<[^>]*>)/)

          for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i].trim()
            if (!token) continue

            if (token.startsWith('</')) {
              // Closing tag - decrease indent
              indent = indent.substring(indentStep.length)
              formatted += indent + token + '\n'
            } else if (token.startsWith('<')) {
              if (token.endsWith('/>') || token.includes('<?xml') || token.includes('<!DOCTYPE')) {
                // Self-closing tag, XML declaration, or DOCTYPE - same indent
                formatted += indent + token + '\n'
              } else {
                // Opening tag - add at current indent, then increase
                formatted += indent + token + '\n'
                // Check if this is not immediately followed by a closing tag
                const nextToken = i + 1 < tokens.length ? tokens[i + 1].trim() : ''
                if (!nextToken.startsWith('</')) {
                  indent += indentStep
                }
              }
            } else {
              // Text content
              if (token.length > 0) {
                formatted += indent + token + '\n'
              }
            }
          }

          return formatted.trim()
        }

        _generateChapterXhtml(chapter, volIdx, chapIdx) {
          if (chapter.type === 'html' || chapter.type === 'xhtml') {
            // Content is already complete HTML/XHTML, use browser APIs to format properly
            try {
              const parser = new DOMParser()
              const doc = parser.parseFromString(chapter.content, 'application/xhtml+xml')

              // Check for parsing errors
              const parserError = doc.querySelector('parsererror')
              if (parserError) {
                // Try parsing as HTML instead
                const htmlDoc = parser.parseFromString(chapter.content, 'text/html')

                // Ensure head element exists
                let head = htmlDoc.querySelector('head')
                if (!head) {
                  head = htmlDoc.createElement('head')
                  htmlDoc.documentElement.insertBefore(head, htmlDoc.body)
                }

                // Add title if missing
                let titleElement = head.querySelector('title')
                if (!titleElement) {
                  titleElement = htmlDoc.createElement('title')
                  titleElement.textContent = chapter.title
                  head.insertBefore(titleElement, head.firstChild)
                }

                // Add viewport meta if missing
                let viewportMeta = head.querySelector('meta[name="viewport"]')
                if (!viewportMeta) {
                  viewportMeta = htmlDoc.createElement('meta')
                  viewportMeta.setAttribute('name', 'viewport')
                  viewportMeta.setAttribute('content', 'width=device-width, height=device-height, initial-scale=1.0')
                  head.appendChild(viewportMeta)
                }

                // Add visible title in body if no heading exists
                const body = htmlDoc.querySelector('body')
                if (body) {
                  const existingHeading = body.querySelector('h1, h2, h3, h4, h5, h6')
                  if (!existingHeading) {
                    const chapterHeading = htmlDoc.createElement('h2')
                    chapterHeading.textContent = chapter.title
                    body.insertBefore(chapterHeading, body.firstChild)
                  }
                }

                // Convert to XHTML format
                const serializer = new XMLSerializer()
                let result = serializer.serializeToString(htmlDoc.documentElement)

                // Add XML declaration if missing
                if (!result.startsWith('<?xml')) {
                  result = '<?xml version="1.0" encoding="UTF-8"?>\n' + result
                }

                // Ensure XHTML namespace
                if (!result.includes('xmlns="http://www.w3.org/1999/xhtml"')) {
                  result = result.replace('<html', '<html xmlns="http://www.w3.org/1999/xhtml"')
                }

                return this._formatXML(result)
              } else {
                // Valid XHTML, ensure head element exists
                let head = doc.querySelector('head')
                if (!head) {
                  head = doc.createElement('head')
                  doc.documentElement.insertBefore(head, doc.body)
                }

                // Add title if missing
                let titleElement = head.querySelector('title')
                if (!titleElement) {
                  titleElement = doc.createElement('title')
                  titleElement.textContent = chapter.title
                  head.insertBefore(titleElement, head.firstChild)
                }

                // Add viewport meta if missing
                let viewportMeta = head.querySelector('meta[name="viewport"]')
                if (!viewportMeta) {
                  viewportMeta = doc.createElement('meta')
                  viewportMeta.setAttribute('name', 'viewport')
                  viewportMeta.setAttribute('content', 'width=device-width, height=device-height, initial-scale=1.0')
                  head.appendChild(viewportMeta)
                }

                // Add visible title in body if no heading exists
                const body = doc.querySelector('body')
                if (body) {
                  const existingHeading = body.querySelector('h1, h2, h3, h4, h5, h6')
                  if (!existingHeading) {
                    const chapterHeading = doc.createElement('h2')
                    chapterHeading.textContent = chapter.title
                    body.insertBefore(chapterHeading, body.firstChild)
                  }
                }

                // Serialize back to clean XHTML
                const serializer = new XMLSerializer()
                let result = serializer.serializeToString(doc)

                // Add XML declaration if missing
                if (!result.startsWith('<?xml')) {
                  result = '<?xml version="1.0" encoding="UTF-8"?>\n' + result
                }

                return this._formatXML(result)
              }
            } catch (error) {
              // Fallback to original content if parsing fails
              console.warn('Failed to parse XHTML content:', error)
              return chapter.content
            }
          } else {
            // Content type is "text", wrap in basic XHTML structure
            const globalCSS = this.cssFiles.get(0)
            let cssLinks = ''

            if (chapter.useGlobalCSS && globalCSS) {
              cssLinks += `        <link rel="stylesheet" type="text/css" href="../Styles/style0.css"/>\n`
            }

            let bodyContent = chapter.content

            // For text type, wrap in paragraph tags and convert newlines
            bodyContent = `        <p>${bodyContent.replace(/\n\n/g, '</p>\n        <p>').replace(/\n/g, '<br/>')}</p>`

            return `<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>${chapter.title}</title>
        <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0"/>
${cssLinks}    </head>
    <body>
        <h1>${chapter.title}</h1>
${bodyContent}
    </body>
</html>`
          }
        }

        async save() {
          // Add mimetype file first (MUST be uncompressed and first in ZIP)
          this.zip.file('mimetype', 'application/epub+zip', { compression: 'STORE' })

          // Create directory structure
          this.zip.folder('META-INF')
          this.zip.folder('OEBPS')
          this.zip.folder('OEBPS/Text')
          this.zip.folder('OEBPS/Styles')
          this.zip.folder('OEBPS/Images')

          // Compression options for all other files (except mimetype)
          const compressionOptions = { compression: 'DEFLATE', compressionOptions: { level: 6 } }

          // Add META-INF/container.xml
          this.zip.file('META-INF/container.xml', this._generateContainer(), compressionOptions)

          // Add OEBPS files
          this.zip.file('OEBPS/content.opf', this._generateContentOpf(), compressionOptions)
          this.zip.file('OEBPS/toc.ncx', this._generateTocNcx(), compressionOptions)
          this.zip.file('OEBPS/nav.xhtml', this._generateNavXhtml(), compressionOptions)

          // Add cover image and page
          if (this.coverBuffer) {
            this.zip.file(`OEBPS/Images/cover.${this.coverExtension}`, this.coverBuffer, compressionOptions)
            this.zip.file('OEBPS/Text/cover.xhtml', this._generateCoverXhtml(), compressionOptions)
          }

          // Add downloaded images
          for (const [filename, imageData] of this.images) {
            this.zip.file(`OEBPS/Images/${filename}`, imageData.buffer, compressionOptions)
          }

          // Add CSS files
          for (const [idx, cssData] of this.cssFiles) {
            this.zip.file(`OEBPS/Styles/style${idx}.css`, cssData.content, compressionOptions)
          }

          // Add CSS map files
          for (const [path, content] of this.cssMap) {
            this.zip.file(`OEBPS/Styles/${path}`, content, compressionOptions)
          }

          // Add chapters
          const sortedVolumes = Array.from(this.volumes.entries()).sort(([a], [b]) => a - b)
          for (const [volIdx, volume] of sortedVolumes) {
            const sortedChapters = Array.from(volume.chapters.entries()).sort(([a], [b]) => a - b)
            for (const [chapIdx, chapter] of sortedChapters) {
              const filename = `OEBPS/Text/chapter_${volIdx}_${chapIdx}.xhtml`
              const content = this._generateChapterXhtml(chapter, volIdx, chapIdx)
              this.zip.file(filename, content, compressionOptions)
            }
          }

          // Generate and return the EPUB buffer
          return await this.zip.generateAsync({ type: 'arraybuffer' })
        }
      }

      class EpubVolume {
        constructor(idx, title, saver) {
          this.idx = idx
          this.title = title
          this.saver = saver
          this.chapters = new Map()
        }

        async addChapter(idx, title, content, type = 'text', useGlobalCSS = false) {
          // Process CSS links and download images from HTML/XHTML content
          let processedContent = content
          if (type === 'html' || type === 'xhtml') {
            processedContent = await this.saver._processCSSLinksInContent(content)
            processedContent = await this.saver._downloadImagesFromContent(processedContent)
          }

          this.chapters.set(idx, {
            title,
            content: processedContent,
            type,
            useGlobalCSS,
          })
        }
      }

      if (globalThis.window == globalThis) {
        window.EpubSaver = EpubSaver
      }
    </script>
  </head>
  <body>
    <button class="toggle-theme" onclick="toggleTheme()">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" id="light">
        <circle cx="12" cy="12" r="10" fill="currentColor" />
      </svg>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" id="dark">
        <path
          fill="currentColor"
          d="M10 2c-1.82 0-3.53.5-5 1.35C7.99 5.08 10 8.3 10 12s-2.01 6.92-5 8.65C6.47 21.5 8.18 22 10 22c5.52 0 10-4.48 10-10S15.52 2 10 2"
        />
      </svg>
    </button>
    <h1 id="title">小说搜索与下载</h1>
    <div id="container" class="container">
      <form class="search-form" id="search-form">
        <select id="search-type" class="search-type">
          <option value="book">书籍</option>
          <option value="audio">听书</option>
        </select>
        <input type="text" id="book-search" placeholder="请输入小说名称" />
        <button type="button" onclick="searchBooks()">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="currentColor"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            display="inherit"
          >
            <path
              d="M16.296 16.996a8 8 0 11.707-.708l3.909 3.91-.707.707-3.909-3.909zM18 11a7 7 0 00-14 0 7 7 0 1014 0z"
            />
          </svg>
        </button>
      </form>
      <div id="book-list" class="book-list"></div>
      <div id="book-info" class="book-info">
        <img src="" alt="封面" id="book-cover" />
        <div class="book-info-container">
          <p id="book_id" style="display: none"></p>
          <p id="book_info" style="display: none"></p>
          <p id="download_lock" style="display: none"></p>
          <h2 id="book-title"></h2>
          <p><strong>作者：</strong><span id="book-author"></span></p>
          <p><strong>分类：</strong><span id="book-category"></span></p>
          <p><strong>状态：</strong><span id="creation-status"></span></p>
          <p><strong>最新章节：</strong><span id="latest-chapter"></span> <span id="latest-chapter-passtime"></span></p>
          <p id="book-description"></p>
          <button class="download-btn" onclick="downloadBook()">下载</button>
          <select id="type-selector" class="charset-selector">
            <option value="text">文本</option>
            <option value="audio">音频</option>
          </select>
          <select id="charset-selector" class="charset-selector">
            <option value="utf-8">UTF-8</option>
            <option value="gbk">GBK</option>
          </select>
          <select id="format-selector" class="charset-selector">
            <option value="txt">TXT</option>
            <option value="epub">EPUB</option>
          </select>
        </div>
      </div>
    </div>
    <!-- 进度条弹窗 -->
    <div id="progress-modal" class="progress-modal" style="display: none">
      <div class="progress-box">
        <h3 id="progress-title" class="progress-title">下载进度</h3>
        <div class="progress-bar">
          <div id="progress-bar-fill" class="progress-bar-fill"></div>
        </div>
        <div class="progress-text">
          <p id="progress-percentage">0%</p>
          <p id="progress-count">0/0</p>
        </div>
        <div id="sub-progress" style="display: none">
          <div class="progress-bar">
            <div id="sub-progress-bar-fill" class="progress-bar-fill"></div>
          </div>
          <p id="sub-progress-title" class="progress-text">副标题</p>
        </div>
        <button id="progress-cancel" class="progress-cancel">取消</button>
        <button id="progress-submit" class="progress-submit" style="display: none">确定</button>
        <button id="button-resave" class="button-resave" style="display: none" onclick="reSave()">手动保存</button>
        <button id="button-redownload" class="button-redownload" style="display: none" onclick="reDownload()">
          重新下载
        </button>
      </div>
    </div>
    <!-- 点击书名后的弹窗 -->
    <dialog id="internal-alert" class="internal-alert">
      <div id="internal-alert-container" class="internal-alert-container">
        <span>内容</span>
      </div>
    </dialog>
    <hr />
    <div class="footer">
      <div class="about-container">
        <p class="about-text">
          本网页为 <a href="https://github.com/MeoProject/PyFQWeb">PyFQWeb</a> 项目的一部分，请遵守开源协议使用
        </p>
      </div>
    </div>
    <script>
      const apiNode = ''
      if (!apiNode) alert('请配置apiNode后再使用网页（需要支持跨域）')

      function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms))
      }

      function btoaEh(str) {
        const bytes = new TextEncoder().encode(str)

        let binary = ''
        bytes.forEach(b => (binary += String.fromCharCode(b)))

        return btoa(binary)
      }

      // 设置页面主题
      function setTheme(theme) {
        document.body.dataset.theme = theme
        document.getElementById(theme).setAttribute('display', 'block')
        document.getElementById(theme === 'dark' ? 'light' : 'dark').setAttribute('display', 'none')
      }

      // 自动检测浏览器主题并设置页面主题
      function setThemeBasedOnPreference() {
        const savedTheme = localStorage.getItem('theme')
        if (savedTheme) {
          setTheme(savedTheme)
        } else {
          const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'
          setTheme(systemTheme)
        }
      }

      // 切换主题并保存到localStorage
      function toggleTheme() {
        const currentTheme = document.body.dataset.theme || 'light'
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark'
        setTheme(newTheme)
        localStorage.setItem('theme', newTheme)
      }

      // 初始化主题
      setThemeBasedOnPreference()
      // 初始化form提交事件
      document.getElementById('search-form').addEventListener('submit', function (event) {
        event.preventDefault()
        searchBooks()
      })

      function formatCount(num, lang) {
        const units = {
          zh: [
            { d: 1e8, s: '亿' },
            { d: 1e4, s: '万' },
          ],
          en: [
            { d: 1e9, s: 'billion' },
            { d: 1e6, s: 'million' },
            { d: 1e3, s: 'thousand' },
          ],
          ja: [
            { d: 1e8, s: '億' },
            { d: 1e4, s: '万' },
          ],
          ko: [
            { d: 1e8, s: '억' },
            { d: 1e4, s: '만' },
          ],
          de: [
            { d: 1e9, s: 'Milliarde' },
            { d: 1e6, s: 'Million' },
            { d: 1e3, s: 'Tausend' },
          ],
          es: [
            { d: 1e9, s: 'mil millones' },
            { d: 1e6, s: 'millón' },
            { d: 1e3, s: 'mil' },
          ],
          ru: [
            { d: 1e9, s: 'миллиард' },
            { d: 1e6, s: 'миллион' },
            { d: 1e3, s: 'тысяча' },
          ],
          ar: [
            { d: 1e9, s: 'مليار' },
            { d: 1e6, s: 'مليون' },
            { d: 1e3, s: 'ألف' },
          ],
        }

        const browserLang = (navigator.language || 'en').substring(0, 2)
        const targetLang = units[lang] ? lang : units[browserLang] ? browserLang : 'en'

        const unit = units[targetLang].find(u => num >= u.d) || { d: 1, s: '' }
        const value = num / unit.d

        const formatted = value
          .toLocaleString(targetLang, {
            maximumFractionDigits: 3,
            minimumFractionDigits: 0,
          })
          .replace(/\.0+$/, '')

        return targetLang === 'ar' ? `${formatted}\u202C${unit.s}\u202C` : `${formatted}${unit.s}`
      }

      function formatDuration(seconds) {
        // 处理负数边界情况
        const totalSeconds = Math.max(0, Math.round(seconds))

        // 时间单位分解
        const hours = Math.floor(totalSeconds / 3600)
        const remaining = totalSeconds % 3600
        const minutes = Math.floor(remaining / 60)
        const secs = remaining % 60

        // 构建时间片段
        const timeFragments = []
        if (hours > 0) {
          timeFragments.push(hours.toString().padStart(2, '0'), minutes.toString().padStart(2, '0'))
        } else {
          timeFragments.push(minutes.toString().padStart(2, '0'))
        }
        timeFragments.push(secs.toString().padStart(2, '0'))

        return timeFragments.join(':')
      }

      function isShitBrowser() {
        const userAgent = navigator.userAgent.toLowerCase()
        return /qua|qqbrowser|micromessenger|quark|baidu|uc|mbrowser/i.test(userAgent)
      }

      function timeStampFormat(ts) {
        return moment(parseInt(ts) * 1000).format('YYYY-MM-DD HH:mm:ss')
      }

      if (isShitBrowser()) {
        let now = Date.now()
        while (Date.now() - now < 30000) {
          alert(
            '本站使用JS原生下载API\n请不要使用 夸克 QQ浏览器 百度 等国产魔改浏览器，否则你将无法正常保存书籍\n建议右转下载Via使用，谢谢\n本通知持续30秒，如果您执意要使用类似浏览器，请等30秒'
          )
        }
      }

      function matchId(url) {
        const regex = /(?:\/page\/(\d{19})|[\?&]book_id=(\d{19}))/
        const match = url.match(regex)

        if (match || (url.length === 19 && !Number.isNaN(parseInt(url)))) {
          return match ? match[1] || match[2] : url
        } else {
          return null
        }
      }

      // 搜索书籍
      async function searchBooks(k) {
        const query = k || document.getElementById('book-search').value.trim()
        const type = document.getElementById('search-type').value || 'book'
        const typeMap = {
          book: 3,
          audio: 2,
        }
        if (!query) {
          return
        }
        let _book_id = matchId(query)
        if (_book_id) {
          return await showBookInfo(_book_id)
        }
        const offset = 0 // 默认偏移量
        const tabType = typeMap[type]
        const url = `${apiNode}/search?query=${query}&offset=${offset}&tab_type=${tabType}`

        try {
          const response = await fetch(url)
          const data = await response.json()
          // console.log(data)
          const resp = data.search_tabs.find(tab => tab.tab_type === typeMap[type])?.data || []
          let searchResults = []
          for (let i of resp) {
            let obj = (i.book_data || [])[0]
            if (obj) searchResults.push(obj)
          }
          displaySearchResults(searchResults)
        } catch (error) {
          console.error('搜索失败:', error)
        }
      }

      // 显示搜索结果
      function displaySearchResults(results) {
        const bookList = document.getElementById('book-list')
        bookList.innerHTML = '' // 清空列表
        results.forEach(result => {
          const bookItem = document.createElement('div')
          bookItem.classList.add('book-item')
          bookItem.dataset.bookId = result.book_id
          bookItem.innerHTML = `
            <div>${result.book_name}</div>
            <div>${result.author}</div>
          `
          bookItem.addEventListener('click', () => showBookInfo(result.book_id))
          bookList.appendChild(bookItem)
        })
        const bookInfo = document.getElementById('book-info')
        bookInfo.style.display = 'none' // 隐藏书籍详情区域
      }

      // 显示书籍详细信息
      async function showBookInfo(bookId) {
        const platformMap = {
          1967: '番茄APP',
          1128: '抖音',
          13: '今日头条',
        }
        // console.log('saveAs', saveAs)
        const bookList = document.getElementById('book-list')
        bookList.innerHTML = '' // 清空搜索列表
        const url = `${apiNode}/info?book_id=${bookId}`
        try {
          const response = await fetch(url)
          const data = await response.json()
          const bookData = data.data || {} // 返回的数据在`data`字段中

          // 填充书籍信息到页面
          const bookInfo = document.getElementById('book-info')
          bookInfo.style.display = 'flex' // 显示书籍详情区域

          document.getElementById('book_id').innerHTML = bookId
          document.getElementById('book_info').innerHTML = JSON.stringify(bookData)
          document.getElementById('book-title').textContent = bookData.book_name || '未知标题'
          document.getElementById('book-author').textContent = bookData.author || '未知作者'
          document.getElementById('book-category').textContent = bookData.category || '未知分类'
          document.getElementById('book-description').textContent = bookData.abstract || '暂无简介'
          document.getElementById('book-cover').src = bookData.thumb_url || 'default_cover.jpg' // 默认封面
          document.getElementById('creation-status').textContent = ['未知', '完结', '连载', null, null, null, '断更'][
            (bookData.creation_status << 0) + 1
          ]
          document.getElementById('latest-chapter').textContent = bookData.last_chapter_title || '未知'
          document.getElementById('latest-chapter-passtime').textContent = timeStampFormat(
            bookData.last_chapter_first_pass_time
          )
          document.getElementById('internal-alert-container').innerHTML = `
<h3 align="center">基础信息</h3>
<p>书籍ID: ${bookData.book_id}  <a href="https://fanqienovel.com/page/${
            bookData.book_id
          }" target="_blank">去官方</a> <a href="legado://import/addToBookshelf?src=https%3A%2F%2Ffanqienovel.com%2F${
            bookData.book_id
          }">在开源阅读查看</a> <a href="dragon1967://reading?bookId=${bookData.book_id}">在番茄小说查看</a></p>
<p>当前报告返回书名: ${bookData.book_name}</p>
<p>书籍源名（作者开书使用的名字）: ${bookData.original_book_name} <a href="https://p6-novel.byteimg.com/origin/${
            bookData.thumb_uri
          }" target="_blank">查看封面</a></p>
<p>书籍别名（书籍宣发使用的名字）: ${bookData.book_flight_alias_name || '无'} ${
            bookData.book_flight_alias_name
              ? '<a href="https://p6-novel.byteimg.com/origin/' +
                bookData.book_flight_alias_thumb +
                '" target="_blank">查看封面</a>'
              : ''
          }</p>
<p>短书名: ${bookData.book_short_name || '无'}</p>
<p>字数: ${formatCount(bookData.word_number)} (${bookData.word_number})</p>
<p>书籍创建时间: ${moment(bookData.create_time).format('YYYY-MM-DD HH:mm:ss')} (${bookData.create_time})</p>
<p>分类: ${bookData.category}</p>
<p>标签: ${bookData.tags}</p>
<p>读者数: ${formatCount(bookData.read_count)} (${bookData.read_count})</p>
<p>听书人数: ${formatCount(bookData.listen_count)} (${bookData.listen_count})</p>
<p>书籍分类: ${bookData.gender ? ['女频', '男频', '出版'][bookData.gender << 0] || '未知' : '未知'} (${
            bookData.gender
          })</p>
<p>当前状态: ${['未知', '完结', '连载', null, null, null, '断更'][(bookData.creation_status << 0) + 1] || '未知'} (${
            bookData.creation_status
          })</p>
<p>ISBN: ${bookData.isbn || '书籍无出版数据'}</p>
<p>${bookData.copyright_info.replace('，如有任何疑问，请通过“我的-意见反馈”告知我们', '')}。</p>
<hr>
<h3 align="center">简介</h3>
<p>${('\u3000\u3000' + bookData.book_abstract_v2.split('\n').join('<br />\u3000\u3000')).replace(
            /[\u3000]+/g,
            '\u3000\u3000'
          )}</p>
<hr>
<h3 align="center">数据信息</h3>
<p>听书总时长: ${formatDuration(bookData.duration)} (${bookData.duration}s)</p>
<p align="center"><strong>以下数据仅供参考</strong></p>
<p>活跃读者数: ${formatCount(bookData.read_count)} (${bookData.read_count}) | 总读者数: ${formatCount(
            bookData.read_count_all
          )} (${bookData.read_count_all}) | 占比: ${((bookData.read_count / bookData.read_count_all) * 100).toFixed(
            3
          )}%</p>
<p>总加书架数: ${formatCount(bookData.shelf_cnt_history)} (${bookData.shelf_cnt_history}) | 14日加书架数: ${formatCount(
            bookData.add_shelf_count_14d
          )} (${bookData.add_shelf_count_14d}) | 占比: ${(
            (bookData.add_shelf_count_14d / bookData.shelf_cnt_history) *
            100
          ).toFixed(3)}%</p>
<hr>
<h3 align="center">各子平台上线时间</h3>
<p>没做</p>
`
        } catch (error) {
          console.error('获取书籍详情失败:', error)
          alert('获取书籍详情失败')
        }
      }

      // 分割 Array
      const chunkArray = (arr, size) => {
        const result = []
        for (let i = 0; i < arr.length; i += size) {
          result.push(arr.slice(i, i + size))
        }
        return result
      }

      // 修复章节带特殊符号的
      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
      }

      // 高清化封面
      const replaceCover = u => {
        if (u.startsWith('https://')) u = u.substring(8)
        else u = u.substring(7)
        let uArr = u.split('/')
        uArr[0] = 'https://p6-novel.byteimg.com/origin'
        let uArr2 = []
        uArr.forEach(x => {
          if (!x.includes('?') && !x.includes('~')) uArr2.push(x)
          else uArr2.push(x.split('~')[0])
        })
        u = uArr2.join('/')
        return u
      }

      async function downloadEpub(result, catalog, bookData, progress, cssMap) {
        const saver = new EpubSaver()
        let intr = ''
        await saver.setInfo('title', bookData.book_name)
        intr += `分类：${JSON.parse(bookData.category_v2)
          .map(item => item.Name)
          .join('、')}\n`
        intr += `主角：${JSON.parse(bookData.roles || '[]').join('、')}\n`
        intr += `简介：${bookData.abstract}\n`
        intr += `${bookData.copyright_info.replace('，如有任何疑问，请通过“我的-意见反馈”告知我们', '')}。`
        await saver.setInfo('description', intr)
        await saver.setInfo('generator', 'PyFQWeb - WebDownloader / EpubSaver.js')
        await saver.setInfo('language', 'zh-CN')
        await saver.setInfo('creator', bookData.author)
        await saver.setInfo('author', bookData.author)
        await saver.cover(replaceCover(bookData.thumb_url))
        // 这个从番茄 APP 里偷出来的
        await saver.addCSS(
          0,
          `html{
    display:block;
}

body{
    display:block;
}

p{
    font-size:1em;
    text-align:justify;
    display:block;
    text-indent:2em;
    margin:0.6em 0em 0.6em 0em;
}

div{
    display:block;
}

h1{
    display:block;
    font-size:1.42em;
    font-weight:bold;
    margin:22px 0em 3em 0em;
    text-align:left;
    line-space:0.5em;
}

h2{
    display:block;
    font-size:1.2em;
    font-weight:bold;
    margin:1em 0em 0.6em 0em;
    text-align:left;
}

h3{
    display:block;
    font-size:1em;
    font-weight:bold;
    margin:0em 0em 1em 0em;
    text-align:left;
}

sup{
    font-size:smaller;
}

.picture{
    text-indent:0em;
    text-align:center;
    margin:0em 0em 0em 0em;
    line-space:0em;
}

.pictureDesc{
    font-size:0.73em;
    text-indent:0em;
    margin:0.4em 0em 1em 0em;
    theme-color:color1#0.7;
    line-space:0.3em;
    text-align:left;
}

.pictureTitle{
    font-size:0.73em;
    text-indent:0em;
    margin:1em 0em 0.3em 0em;
    theme-color:color1#0.7;
    text-align:left;
    line-space:0em;
}

.collectTitle{
    margin:80px 68px 0em 0px;
    font-size:1.42em;
    text-indent:0em;
    text-align:left;
}

.collectAuthor{
    margin:16px 0em 0em 0em;
    font-size:1em;
    text-indent:0em;
    text-align:left;
}

.collectPicture{
    margin:24px 0em 0em 0em;
    text-indent:0em;
    text-align:right;
}

.collectDetail{
    margin:3em 44px 0em 10px;
    text-indent:0em;
}

.quoteDefault{
    font-size:1em;
    margin:1.5em 0em 1.5em 2em;
    font-family:'FZShengShiKaiShuS-M-GB';
    line-space:0.5em;
}

.quoteStyle1{
    text-indent:0em;
    text-align:left;
}

.alignRight{
    text-align:right;
}

.quoteDefaultAlignRight{
    font-size:1em;
    margin:0.6em 0em 1.5em 32px;
    font-family:'FZShengShiKaiShuS-M-GB';
    text-align:right;
    line-space:0.5em;
}
.chapterTitle1{
    display:block;
    font-size:1.42em;
    font-weight:bold;
    margin:22px 0em 3em 0em;
    text-align:left;
    line-space:0.5em;
}

.chapterTitle2{
    display:block;
    font-size:1.2em;
    font-weight:bold;
    margin:1em 0em 0.6em 0em;
    text-align:left;
}

.chapterTitle3{
    display:block;
    font-size:1em;
    font-weight:bold;
    margin:0em 0em 1em 0em;
    text-align:left;
}

.bdFootnote{
    width:0.69em;
    height:0.84em;
    margin-top:-0.23em;
    vertical-align:top;
}

.bdPicturebg{
    break-before:always;
}`,
          'Styles/dragon-common.css'
        )
        let cssMapIdx
        if (cssMap && typeof cssMap === 'object') {
          cssMapIdx = await saver.addCSSMap(cssMap)
        }
        let volname = '默认卷'
        let curvolidx = 0
        let cursor = 0
        let currentVolume
        for (const i of catalog) {
          if (progress.isCancelled) break
          const data = result[i.item_id]
          if (data?.novel_data?.volume_name && volname != data.novel_data.volume_name) {
            volname = data.novel_data.volume_name
            currentVolume = await saver.addVolume(curvolidx++, volname)
            console.log('更换卷', currentVolume)
          }
          if (typeof currentVolume === 'undefined') {
            currentVolume = await saver.addVolume(curvolidx, volname)
            console.log('创建新卷', currentVolume)
          }
          const curChapContent = data.content || '<p>正文内容为空</p>'
          await currentVolume.addChapter(
            cursor++,
            i.title,
            curChapContent,
            curChapContent.includes('xhtml') ? 'xhtml' : 'html',
            true
          )
          progress.updateProgressBar(cursor)
        }
        if (progress.isCancelled) {
          delete saver
          return
        }
        progress.updateTitle('正在生成EPUB...')
        progress.total = 1
        progress.updateProgressBar(0)
        const epub = await saver.save()
        console.log(epub)
        progress.updateProgressBar(1)
        progress.updateTitle('执行完成，正在保存')
        progress.complete(false)
        const blob = new Blob([epub], { type: 'application/epub+zip' })
        saveAs(blob, `${bookData.book_name}_${bookData.author}.epub`)
      }

      // 下载书籍
      async function downloadBookExecutor() {
        window.downloadResult = ''
        const Lock = document.getElementById('download_lock')
        const charset = document.getElementById('charset-selector').value.toLowerCase()
        const fileformat = document.getElementById('format-selector').value.toLowerCase()
        if (fileformat === 'epub' && charset === 'gbk') {
          alert('EPUB格式仅支持UTF-8编码')
          return
        }
        console.log(charset)

        let taskId = `task_${Date.now()}`
        console.log(taskId)
        if (Lock.innerHTML.trim() !== '') {
          console.warn(Lock.innerHTML.trim() !== '', '下载按钮重复点击')
          return
        } else {
          Lock.innerHTML = taskId
        }

        const bookId = document.getElementById('book_id').innerHTML
        if (!bookId) {
          alert('请先选择一本书籍！')
          return
        }

        const catalogUrl = `${apiNode}/catalog?book_id=${bookId}`
        let catalog
        let cssMap

        try {
          const response = await fetch(catalogUrl)
          const body = await response.json()
          catalog = body.data?.item_data_list
          cssMap = body.data?.css_map
        } catch (error) {
          console.error('获取目录失败', error)
        }

        if (!catalog) {
          alert('获取目录失败或目录为空')
          console.error(catalog)
          Lock.innerHTML = ''
          return
        }

        let progress = showProgressWindow('下载', catalog.length)
        progress.updateTitle('准备中...')

        const item_ids = catalog.map(item => item.item_id)
        const result = {}
        let cursor = 0

        const maxConcurrentRequests = 64

        const downloadChunks = async () => {
          const concurrencyLimit = maxConcurrentRequests
          const totalItems = item_ids.length
          const retryMap = new Map() // 记录每个item的重试次数

          // 创建异步任务队列
          const queue = item_ids.map(item_id => ({
            item_id,
            status: 'pending',
            retries: 0,
          }))

          let activeCount = 0
          let cursor = 0
          let hasError = false

          return new Promise(resolve => {
            const runWorker = async () => {
              while (queue.length > 0 && !hasError && !progress.isCancelled) {
                if (activeCount >= concurrencyLimit) return

                const task = queue.shift()
                if (!task || task.status === 'success') return

                activeCount++
                let success = false

                try {
                  while (task.retries <= 3) {
                    if (progress.isCancelled) break

                    const response = await fetch(`${apiNode}/content?item_id=${task.item_id}`)
                    const body = await response.json()

                    if (body.data?.content) {
                      result[task.item_id] = body.data
                      cursor++
                      progress.updateProgressBar(cursor)
                      progress.updateTitle('缓存中... | ' + (catalog[cursor] || {}).title)
                      success = true
                      break
                    } else {
                      task.retries++
                      await new Promise(r => setTimeout(r, 300)) // 错误章节等会再下
                    }
                  }
                } catch (error) {
                  console.error(`item ${task.item_id} failed:`, error)
                } finally {
                  activeCount--

                  if (!success) {
                    // hasError = true;
                    result[task.item_id] = { error: 'Max retries exceeded' }
                    console.warn(`Item ${task.item_id} failed after 3 retries`)
                  }

                  // 立即触发下一个任务
                  if (!hasError && !progress.isCancelled) {
                    if (queue.length > 0 || activeCount > 0) {
                      runWorker()
                    } else {
                      resolve(true)
                    }
                  }
                }
              }

              // 所有任务完成检测
              if (activeCount === 0 && queue.length === 0) {
                resolve(!hasError)
              }
            }

            // 启动初始并发数
            for (let i = 0; i < Math.min(concurrencyLimit, queue.length); i++) {
              runWorker()
            }
          })
        }

        let isSuccess = await downloadChunks()
        if (!isSuccess) {
          return
        }

        console.log(Object.keys(result).length)
        progress.updateTitle('处理章节中...')
        cursor = 0
        progress.updateProgressBar(cursor)
        let content = ''
        let bookData = JSON.parse(document.getElementById('book_info').innerHTML)

        if (fileformat === 'epub') return downloadEpub(result, catalog, bookData, progress, cssMap)

        content += bookData.book_name + '\n'
        content += `作者：${bookData.author}\n`
        content += `分类：${JSON.parse(bookData.category_v2)
          .map(item => item.Name)
          .join('、')}\n`
        content += `主角：${JSON.parse(bookData.roles || '[]').join('、')}\n`
        content += `简介：${bookData.abstract}\n`
        content += `${bookData.copyright_info.replace('，如有任何疑问，请通过“我的-意见反馈”告知我们', '')}。\n\n\n`

        let volname
        for (let i of catalog) {
          let data = result[i.item_id]
          cursor++
          if (data?.novel_data?.volume_name && volname != data.novel_data.volume_name) {
            content += `${data.novel_data.volume_name.replace('：默认', '')}\n\n`
            volname = data.novel_data.volume_name
          }
          let text =
            `${i.title}\n\u3000\u3000` +
            htmlToTextArray(
              (data?.content || '<p>章节内容为空</p>').replace(new RegExp(escapeRegExp(i.title), 'g'), '')
            )
              .join('\n\u3000\u3000')
              .trim() +
            '\n\n\n' // .replace(`${i.title}\n\u3000\u3000${i.title}`, i.title) + '\n\n\n';
          content += text
          progress.updateProgressBar(cursor)
        }

        progress.updateTitle('执行完成，正在保存')
        const file = `${bookData.book_name}_${bookData.author}.txt`
        window.downloadResult = {
          content,
          file,
        }
        progress.complete()
        let encoded = charset === 'gbk' ? encodeGBK(content) : new TextEncoder(charset).encode(content)
        const blob = new Blob([encoded], { type: `text/plain;charset=${charset}` })
        saveAs(blob, file)
        Lock.innerHTML = ''
      }

      async function getCORSAvailableAudioURL(item_id, tone_id, try_num = 0) {
        if (try_num > 3) {
          throw new Error('try max num')
        }
        try {
          const apiUrl = `${apiNode}/audio?item_ids=${item_id}`
          const response = await fetch(apiUrl)
          const body = await response.json()
          const item = body.data[0]
          let urls = [item.main_url, item.backup_url]
          urls = urls.filter(_ => !_.includes('://v3-'))
          return urls[0] || getCORSAvailableAudioURL(item_id, tone_id, try_num++)
        } catch (e) {
          console.error(e)
          return getCORSAvailableAudioURL(item_id, tone_id, try_num++)
        }
      }

      async function downloadAudioExecutor() {
        const tone_id = prompt(
          '部分浏览器会弹出警告，网页尝试下载多个文件，请允许请求！\n请输入音色ID（对于番茄畅听类真人朗读，这个值会被忽略）: ',
          '1'
        )
        window.downloadResult = ''
        const Lock = document.getElementById('download_lock')

        let taskId = `task_${Date.now()}`
        console.log(taskId)
        if (Lock.innerHTML.trim() !== '') {
          console.warn(Lock.innerHTML.trim() !== '', '下载按钮重复点击')
          return
        } else {
          Lock.innerHTML = taskId
        }

        const bookId = document.getElementById('book_id').innerHTML
        if (!bookId) {
          alert('请先选择一本书籍！')
          return
        }

        let catalog
        const catalogUrl = `${apiNode}/catalog?book_id=${bookId}`
        try {
          const response = await fetch(catalogUrl)
          const body = await response.json()
          catalog = body.data?.item_data_list
        } catch (error) {
          console.error('获取目录失败', error)
        }

        if (!catalog) {
          alert('获取目录失败或目录为空')
          console.error(catalog)
          Lock.innerHTML = ''
          return
        }

        const progress = showProgressWindow('下载', catalog.length, true)
        progress.updateTitle('准备中...')
        progress.subProgress.updateTitle('准备中')

        // 添加取消监听
        let activeXHR = null
        progress.onCancel = () => {
          console.log(activeXHR)
          if (activeXHR) {
            activeXHR.abort()
            activeXHR = null
          }
          Lock.innerHTML = ''
        }

        try {
          for (let index = 0; index < catalog.length; index++) {
            // 检查取消状态
            if (progress.isCancelled) {
              console.warn('aborting...')
              break
            }

            const item = catalog[index]

            // 更新主进度
            progress.updateProgressBar(index)
            progress.updateTitle(`缓存中: ${item.title}`)

            // 重置副进度
            progress.subProgress.updateProgressBar(0)
            progress.subProgress.updateTitle('等待开始...')

            // 获取下载链接
            const aurl = await getCORSAvailableAudioURL(item.item_id, tone_id).catch(() => null)
            if (!aurl) {
              console.error('目录', item.item_id, item.title, '解析失败')
              continue
            }

            // 创建下载任务
            const { promise, xhr } = createDownloadTask(aurl, item, progress)
            activeXHR = xhr // 保存当前XHR引用

            try {
              await promise
              progress.updateProgressBar(index + 1)
            } catch (e) {
              if (e.name !== 'AbortError') {
                console.error(`下载失败: ${item.title}`, e)
              }
              if (progress.isCancelled) break
            }
          }
        } finally {
          activeXHR = null
          if (!progress.isCancelled) {
            progress.updateTitle('完成')
            progress.complete(false)
          }
          Lock.innerHTML = ''
        }
      }

      // 创建下载任务
      function createDownloadTask(url, item, progress) {
        const callback = {
          ptext: '',
          stext: '',
          onProgress(recv, total) {
            this.ptext = `${formatSize(recv)}/${formatSize(total)}`
            progress.subProgress.updateProgressBar(Math.ceil((recv / total) * 100))
            progress.subProgress.updateTitle(`${this.ptext} | ${this.stext}`)
          },
          onNetSpeed(bps) {
            this.stext = formatSpeed(bps)
            progress.subProgress.updateTitle(`${this.ptext} | ${this.stext}`)
          },
          onComplete: () => {},
          onError: () => {},
        }

        const { xhr, promise } = downloadFile(url, `${item.title}.mp3`, callback)

        const wrappedPromise = promise.catch(e => {
          if (e.name !== 'AbortError') throw e
        })

        return { promise: wrappedPromise, xhr }
      }

      async function downloadBook() {
        const typeSelector = document.getElementById('type-selector')
        const dlType = typeSelector.value || 'text'
        try {
          switch (dlType) {
            case 'text':
              return await downloadBookExecutor()
              break
            case 'audio':
              return await downloadAudioExecutor()
              break
            default:
              console.error('Unknown download type: ', dlType)
              return
          }
        } catch (e) {
          console.error(e)
        }
      }

      function reSave() {
        // 检查 window.downloadResult 是否存在
        if (!window.downloadResult) {
          console.error('window.downloadResult is not defined.')
          return
        }

        alert('请全选新页面内容进行手动保存')
        // 打开新的空白页面
        const newWindow = window.open()

        if (newWindow) {
          newWindow.document.write(`<pre>${window.downloadResult.content}</pre>`) // 显示文本内容
          newWindow.document.close()
        } else {
          console.error('Failed to open a new window.')
        }
      }

      function reDownload() {
        const charset = document.getElementById('charset-selector').value.toLowerCase()
        let encoded =
          charset === 'gbk'
            ? encodeGBK(window.downloadResult.content)
            : new TextEncoder(charset).encode(window.downloadResult.content)
        const blob = new Blob([encoded], { type: `text/plain;charset=${charset}` })
        saveAs(blob, window.downloadResult.file)
      }

      function getAllTextElements(element, textArray) {
        // 获取当前元素的所有子节点
        const childNodes = element.childNodes

        // 遍历每一个子节点
        childNodes.forEach(node => {
          // 如果是文本节点，将其内容加入到数组中
          if (node.nodeType === Node.TEXT_NODE) {
            textArray.push(node.textContent.trim())
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            // 如果是元素节点，递归调用该函数处理其子元素
            getAllTextElements(node, textArray)
          }
        })
      }

      function htmlToTextArray(html) {
        // 创建一个div，用于存放html内容
        const div = document.createElement('div')

        // 修改div的内容为给定的html
        div.innerHTML = html

        // 获取div中的所有文本内容
        let textArray = []
        getAllTextElements(div, textArray)

        return textArray
      }

      // 已弃用
      async function multiDownloadExecutor(book_id, item_ids, depth = 0) {
        if (!item_ids.length) {
          return {}
        }
        if (depth > 3) {
          alert('下载失败')
          throw new Error('try max num')
        }
        try {
          const response = await fetch(`${apiNode}/multi-content?book_id=${book_id}&item_ids=${item_ids.join(',')}`)
          const result = await response.json()
          // console.log(item_ids, result)
          return result.data
        } catch (err) {
          console.warn('error downloading...', book_id, item_ids, 'retry', depth)
          return await multiDownloadExecutor(book_id, item_ids, depth + 1)
        }
      }

      function showProgressWindow(title, total, showSubProgress) {
        const progressModal = document.getElementById('progress-modal')
        const progressBarFill = document.getElementById('progress-bar-fill')
        const progressPercentage = document.getElementById('progress-percentage')
        const progressCount = document.getElementById('progress-count')
        const progressTitle = document.getElementById('progress-title')
        const progressCancelBtn = document.getElementById('progress-cancel')
        const progressSubmitBtn = document.getElementById('progress-submit')
        const resaveButton = document.getElementById('button-resave')
        const redlButton = document.getElementById('button-redownload')
        const subProgressModal = document.getElementById('sub-progress')
        const subProgressBarFill = document.getElementById('sub-progress-bar-fill')
        const subProgressTitle = document.getElementById('sub-progress-title')

        // 显示进度窗口
        progressModal.style.display = 'flex'
        progressTitle.textContent = title
        progressCount.textContent = `0/${total}`
        progressPercentage.textContent = '0%'
        progressBarFill.style.width = '0%'
        if (showSubProgress) {
          subProgressModal.style = ''
        } else {
          // 必须要加这一步，不然第二次下载不显示副进度条的时候会显示一个空的副进度条
          subProgressModal.style.display = 'none'
        }

        let isCancelled = false
        // 操作对象
        const subProgress = {
          updateTitle(title) {
            subProgressTitle.textContent = title
          },
          updateProgressBar(fillPercent) {
            subProgressBarFill.style.width = `${fillPercent}%`
          },
        }
        const obj = {
          total,
          title,
          isCancelled,
          subProgress,
          updateTitle(title) {
            const progressTitle = document.getElementById('progress-title')
            progressTitle.textContent = title
            this.title = title
          },
          updateProgressBar(current) {
            if (this.isCancelled) return

            const percentage = ((current / this.total) * 100).toFixed(2)
            progressBarFill.style.width = `${percentage}%`
            progressPercentage.textContent = `${percentage}%`
            progressCount.textContent = `${current}/${this.total}`
          },
          cancel() {
            this.isCancelled = true
            progressModal.style.display = 'none'
            document.getElementById('download_lock').innerHTML = ''
            progressCancelBtn.style = ''
            progressSubmitBtn.style.display = 'none'
            redlButton.style.display = 'none'
            resaveButton.style.display = 'none'
            subProgressModal.style.display = 'none'
            if (this.onCancel) this.onCancel()
          },
          complete(allowResave = true) {
            progressSubmitBtn.style = ''
            if (allowResave) {
              resaveButton.style = ''
              redlButton.style = ''
            }
            progressCancelBtn.style.display = 'none'
            subProgressModal.style.display = 'none'
          },
          finish() {
            progressModal.style.display = 'none'
            progressCancelBtn.style = ''
            progressSubmitBtn.style.display = 'none'
            redlButton.style.display = 'none'
            resaveButton.style.display = 'none'
            document.getElementById('download_lock').innerHTML = ''
          },
        }

        // 按钮事件
        progressCancelBtn.onclick = () => {
          obj.cancel()
        }
        progressSubmitBtn.onclick = () => {
          obj.finish()
        }

        return obj
      }

      async function checkMultiDownloadSupport(bookId, itemId) {
        try {
          const response = await fetch(`${apiNode}/multi-content?book_id=${bookId}&item_ids=${itemId}`)
          const _ = await response.json()
          console.log(_)
          if (_.data && _.data.length != 0) {
            return true
          }
          return false
        } catch (err) {
          console.warn(err)
          return false
        }
      }

      function downloadFile(url, filename, callback) {
        // 参数标准化处理
        if (typeof filename === 'object' || typeof filename === 'function') {
          callback = filename
          filename = null
        }
        callback = callback || {}

        const xhr = new XMLHttpRequest()
        xhr.open('GET', url, true)
        xhr.responseType = 'blob'
        xhr.withCredentials = false

        let currentLoaded = 0
        let lastLoaded = 0
        let lastTime = Date.now()
        let netSpeedTimer = null

        xhr.onprogress = event => {
          currentLoaded = event.loaded
          callback.onProgress?.(event.loaded, event.lengthComputable ? event.total : 0)
        }

        netSpeedTimer = setInterval(() => {
          const now = Date.now()
          const timeDiff = (now - lastTime) / 1000
          if (timeDiff > 0) {
            const speed = (currentLoaded - lastLoaded) / timeDiff
            callback.onNetSpeed?.(speed)
            lastLoaded = currentLoaded
            lastTime = now
          }
        }, 500)

        const promise = new Promise((resolve, reject) => {
          xhr.onload = () => {
            clearInterval(netSpeedTimer)
            if (xhr.status >= 200 && xhr.status < 300) {
              try {
                const blob = xhr.response
                const urlObject = URL.createObjectURL(blob)
                const a = document.createElement('a')
                a.href = urlObject
                a.download = filename || getFilenameFromHeaders(xhr) || getFilenameFromUrl(url)
                document.body.appendChild(a)
                a.click()
                setTimeout(() => {
                  document.body.removeChild(a)
                  URL.revokeObjectURL(urlObject)
                  callback.onComplete?.()
                  resolve()
                }, 300)
              } catch (e) {
                callback.onError?.(e)
                reject(e)
              }
            } else {
              handleError(new Error(`HTTP Error ${xhr.status}`))
            }
          }

          const handleError = e => {
            clearInterval(netSpeedTimer)
            callback.onError?.(e)
            reject(e)
          }

          xhr.onabort = () => handleError(new DOMException('Aborted', 'AbortError'))
          xhr.onerror = handleError
        })

        xhr.send()

        return { xhr, promise } // 返回xhr和promise
      }

      // 从响应头获取文件名
      function getFilenameFromHeaders(xhr) {
        try {
          const disposition = xhr.getResponseHeader('Content-Disposition') || ''
          const filename = disposition.split('filename=')[1]?.split(/[;,\r\n]/)[0]
          return filename ? filename.replace(/^['"]|['"]$/g, '') : null
        } catch {
          return null
        }
      }

      function formatSize(bytes) {
        if (bytes === 0) return '0 B'
        const units = ['B', 'KB', 'MB', 'GB']
        const i = Math.floor(Math.log(bytes) / Math.log(1024))
        return `${(bytes / Math.pow(1024, i)).toFixed(1)} ${units[i]}`
      }

      function formatSpeed(bytesPerSecond) {
        if (bytesPerSecond > 1024 * 1024) {
          return `${(bytesPerSecond / 1024 / 1024).toFixed(2)} MB/s`
        }
        return `${(bytesPerSecond / 1024).toFixed(2)} KB/s`
      }

      // 从URL路径获取文件名
      function getFilenameFromUrl(url) {
        try {
          return new URL(url).pathname.split('/').pop() || 'download'
        } catch {
          return 'download'
        }
      }

      const bookNameDialog = document.getElementById('internal-alert')
      bookNameDialog.addEventListener('click', event => {
        const content = bookNameDialog.querySelector('.internal-alert-container')
        const rect = content.getBoundingClientRect()
        const isOutside =
          event.clientX < rect.left ||
          event.clientX > rect.right ||
          event.clientY < rect.top ||
          event.clientY > rect.bottom
        if (isOutside) bookNameDialog.close()
      })
      document.getElementById('book-title').onclick = () => {
        bookNameDialog.showModal()
      }

      const initUrl = new URL(window.location.href)
      // 自动处理参数
      if (initUrl.searchParams.get('book_id') || initUrl.searchParams.get('text')) {
        document.getElementById('search-form').display = 'none'
        searchBooks(initUrl.searchParams.get('book_id') || initUrl.searchParams.get('text'))
      }

      console.log(`hello ^(｡･ω･｡)^`)
      console.log('apiNode', apiNode)
      console.log('saveAs', saveAs)
      console.log('encodeGBK', encodeGBK)
      console.log('EpubSaver', EpubSaver)
    </script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        transition: background-color 0.3s, color 0.3s;
      }

      :root {
        --bg-color: #fffafe;
        --text-color: #000;
        --button-bg: #69b3f0;
        --button-text: #fff;
        --button-hover-bg: #58a2e9;
        --info-bg: #f9f9f9;
        --download-bg: #28a745;
        --download-text: #fff;
        --download-hover-bg: #1e7e34;
        --toggle-bg: #6c757d;
        --toggle-text: #fff;
        --toggle-hover-bg: #5a6268;
        --jump-text: #8898ff;
      }

      [data-theme='dark'] {
        --bg-color: #121212;
        --text-color: #e0e0e0;
        --button-bg: #3498db;
        --button-text: #fff;
        --button-hover-bg: #2980b9;
        --info-bg: #1e1e1e;
        --download-bg: #4caf50;
        --download-text: #fff;
        --download-hover-bg: #3e8e41;
        --toggle-bg: #95a5a6;
        --toggle-text: #fff;
        --toggle-hover-bg: #7f8c8d;
        --jump-text: #c3cbff;
      }

      #title {
        text-align: center;
        padding: 20px;
      }

      .container {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }

      .search-form {
        display: flex;
        justify-content: center;
        /* width: 800px; */
        margin-bottom: 20px;
      }

      .search-form input {
        padding: 10px;
        font-size: 16px;
        border: 1px solid #ccc;
        border-radius: 0 0 0 0;
        /* width: 250px; */
        /* max-width: 85%; */
        transition: width 0.3s;
      }

      .search-form button {
        padding: 10px 20px;
        font-size: 16px;
        border: none;
        width: 40%;
        max-width: 80px;
        background-color: var(--button-bg);
        color: var(--button-text);
        border-radius: 0 15px 15px 0;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      .search-form select {
        padding: 0 5px;
        font-size: 16px;
        border: none;
        width: 40%;
        min-width: 70px;
        background-color: var(--button-bg);
        color: var(--button-text);
        border-radius: 15px 0 0 15px;
        transition: background-color 0.3s;
        text-align: left;
      }

      a {
        color: var(--jump-text);
      }

      .search-form button:hover {
        background-color: var(--button-hover-bg);
      }

      .book-list {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 90%;
        max-width: 600px;
      }

      .book-item {
        display: flex;
        justify-content: space-between;
        width: 100%;
        padding: 10px;
        border-bottom: 1px solid #ccc;
        cursor: pointer;
      }

      .book-item:hover {
        background-color: #777;
      }

      .book-info {
        display: none;
        flex-direction: row;
        border: 1px solid #ccc;
        border-radius: 10px;
        padding: 20px;
        width: 60%;
        background-color: var(--info-bg);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin-top: 20px;
        transition: background-color 0.3s;
      }

      .book-info img {
        display: flex;
        max-width: 40%;
        border-radius: 10px;
        margin-right: 20px;
      }

      .book-info h2 {
        margin: 0 0 10px;
      }

      .book-info p {
        margin: 5px 0;
        text-align: justify;
      }

      .book-info .download-btn {
        padding: 10px 20px;
        font-size: 16px;
        border: none;
        background-color: var(--download-bg);
        color: var(--download-text);
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      .book-info .download-btn:hover {
        background-color: var(--download-hover-bg);
      }

      .book-info .charset-selector {
        padding: 10px 20px;
        font-size: 16px;
        border: none;
        background-color: var(--download-bg);
        color: var(--download-text);
        border-radius: 5px;
      }

      .internal-alert {
        outline: none;
        border: 1px solid #ccc;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
        width: 75%;
        height: 55%;
        background: var(--bg-color);
        border-radius: 8px;
      }
      .internal-alert-container {
        position: relative;
        width: 100%;
        height: 100%;
        color: var(--text-color);
        /*
        display: flex;
        align-items: center;
        justify-content: center;
        */
      }

      .toggle-theme {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 10px;
        font-size: 16px;
        border: none;
        background-color: var(--toggle-bg);
        color: var(--toggle-text);
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      .toggle-theme:hover {
        background-color: var(--toggle-hover-bg);
      }

      .book-info-container {
        flex: 1;
      }

      @media (orientation: portrait) {
        .internal-alert {
          height: 75% !important;
        }
        .book-info {
          width: 90%;
          flex-direction: column;
        }
        .book-info img {
          max-width: 100%;
          border-radius: 10px;
          margin-bottom: 10px;
        }
      }

      .progress-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .progress-box {
        background: var(--bg-color);
        padding: 20px;
        border-radius: 8px;
        text-align: center;
        width: 300px;
      }

      .progress-title {
        position: relative;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        width: 100%;
      }

      .progress-bar {
        width: 100%;
        background: #f3f3f3;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 10px;
      }

      .progress-bar-fill {
        height: 20px;
        background: #4caf50;
        width: 0%;
        transition: width 0.2s;
      }

      .progress-text {
        margin-bottom: 10px;
      }

      .progress-cancel {
        padding: 5px 10px;
        background: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      .button-resave,
      .button-redownload,
      .progress-submit {
        padding: 5px 10px;
        background: var(--download-bg);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      .button-resave:hover,
      .button-redownload:hover,
      .progress-submit:hover {
        background: var(--download-hover-bg);
      }

      .footer {
        width: 100%;
        display: flex;
        justify-content: center;
      }

      .about-container {
        text-align: center;
        max-width: 75%;
      }

      .about-text {
        color: #878787;
        margin: 0;
      }
    </style>
  </body>
</html>
